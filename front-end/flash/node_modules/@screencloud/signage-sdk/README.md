# Signage SDK

Runtimes and helpers to develop apps on ScreenCloud's Digital Signage platform.

## About Apps in Signage
All apps running in ScreenCloud are web-apps, which are loaded by a
Player in a secure environment. There are no constraints on the technologies or frameworks to be used.

Apps get published to the AppRegistry and can be public and available to everyone or private and only
visible to a selected group. In order to publish your App to the Registry you need to have at
least a `manifest.json` defined. You can bootstrap this file by using `@screencloud/signage-cli` and running `signage init` in your project 
folder.

Among other things such as name, author and version, the manifest will contain a `viewerUrl`, which should point to your app. Either
using an absolute path hosted in the web or a path relative to the `manifest.json`, specifying a static
entry file such as `build/app/index.html`.

This is enough to get your app running, but most apps can be customized or configured to diversify the app. For instance
an App to show game results may offer a list of sports or teams to choose from. There are different ways to do this and
which one you choose may highly depend on your app and possibly existing infrastructure. Learn more about configuring app
instances [WIP](example.com).

## Install
This package is available on npm as `@screencloud/signage-sdk`.

To install run
```bash
npm install @screencloud/signage-sdk --save
```

### CLI
You may choose to install our CLI as well by running `npm i -g @screencloud/signage-cli`. Afterwards run `signage --help`.

The CLI can also be installed on a package level via `npm i @screencloud/signage-cli --save-dev`. If run globally in a
project directory with a local installation, it will fallback to the local version automatically.

### Supported Frameworks
This package is framework-agnostic and doesn't offer any framework specific tools or classes. 

For some more popular frameworks we offer a extensions to this SDK:
- React: `@screencloud/signage-sdk-react` offers Contexts and HOCs for classes such as `AppPlayer` and `EditorPlayer`.

## Creating an App
This SDK provides an `AppPlayer`-class, which is an abstraction of the Player above and simplifies interacting with it.
It's the most convenient way to get your app running and we recommend all Apps to use it. 

### Basics
The first thing your app has to do, is signaling the Player above that your app has been loaded successfully. 
This is done by connecting to it.

For this we need to instantiate `AppPlayer` and call it's `async connect()`-method, which will return a Promise to be
resolved once a connection has been established.

```ts
import {AppPlayer} from "@screencloud/app";

const appPlayer = new AppPlayer();

appPlayer.connect().then(() => {
  // you're connected to the player now!
});
```

### Responding to lifecycle-events
Your App and the Player communicate via a bunch of lifecycle-events called Messages. For each incoming message from 
the Player there is a matching method in `AppPlayer`. The player may for instance send a `FinishMessage` to your app
to announce that your app will be turned off in favor of the next app. This message comes with a payload specifying
your apps remaining duration, so you can react to it and shut down gracefully.

```ts
appPlayer.onFinish((payload) => {
    // app will be turned off in payload.maximumDurationMS   
});
```

Note that all lifecycle handlers are chainable, so you can set up your handlers like so:
```ts
const appPlayer = (new AppPlayer())
    .onInitialize((payload => {
        // receive env variables and app data
    })
    .onPreload((payload) => {
        // preload data
    })
    .onStart(() => {
        // the app is live!
    })
    .onFinish(() => {
        // app will turn off, fade out gracefully
    })
    .connect();
```

Alternatively you can pass in a collection of handlers into AppPlayer's constructor
```ts
const appPlayer = new AppPlayer({
    initialize: (payload) => {
        // receive env variables and app data
    },
    start: () => {
        // the app is live!
    },
    finish: (payload) => {
        // app will turn off, fade out gracefully
    },
});

appPlayer.connect();
```

### Sending lifecycle events
Your app can send numerous events to its player. For each outgoing message there is an emitter-method
like `emitPreloaded()`. You can call these methods to inform the player about the app's current state
or to respond to incoming messages as seen above.

If your app for instance specifies in its `manifest.json` that it supports preloading, then the app-container may 
send a `PreloadMessage` to your app, which you can handle by supplying a callback function to `onPreload()`. Once 
your app has finished preloading, it should inform the app-container by calling `emitPreloaded()`.

```ts
const appPlayer = new AppPlayer();

appPlayer.onPreload((payload) => {
    // preload some data from twitter or any other api
    twitter.loadSomeThings().then(() = {
        // inform app-container 
        appPlayer.emitPreloaded();
    });
})
```

### Requesting resources
The player also provides certain services to your App such as Signed URLs for content stored 
on signage and signed JWTs to connect to your app's backend securely.

Methods for this are all prefixed with `request` such as `requestAuthorizationHeader()` and always return a promise.

## List of Lifecycle events
These are all available incoming events, outgoing events and resource requests an app can receive or utilize during its lifetime. 

### Incoming events
| incoming event | handler | description |
| --- | --- | --- |
| initialize | onInitialize | provides app, environment and related data to the app. Called shortly after a connection has been established. The app should respond with `emitInitialized` when ready. |
| preload | onPreload | instructs the app to preload all required resources to run. The app should `emitPreloaded` when ready. The event may supply additional data as payload. |
| start | onStart | the app is now visible on screen and should start to play animations as well as video and/or audio content |
| show | onShow | the app container request to show a specific piece of content. This is used for long-running apps which may receive content updates during their lifetime. |
| finish | onFinish | the app will terminate soon and should prepare to be shut down. A maximum duration is provided as payload. The app should respond with `emitFiniching` with an estimated duration and `emitFinished` when ready to be shut down. |

### Outgoing events
| outgoing event | emitter | description |
| --- | --- | --- |
| initialized | emitInitialized | tells the app-container that the app is loaded and working. Should be sent after receiving an `initialize`-event. |
| preloaded | emitPreloaded |  tells the app-container that the app has finished preloading and is ready to start immediately. Should be sent after receiving a `preloaded`-event. |
| started | emitStarted | tell the app-container that the app is visible and running. |
| showing | emitShowing | informs the app-container which piece of content is currently shown. This is useful for logs and statistics. |
| finishing | emitFinishing | informs the app-container that the app will be ready to shut off soon. An estimated duration should be provided as payload. |
| finished | emitFinished | the app is ready to shut down immediately. |
| log | emitLog | sends a log entry to be centrally stored. Using payload you can specify the severity from `LogLevel.debug` to `LogLevel.error` as well as a message. |

### Resource requests
TODO: none defined yet

## Debugging and testing
There are special classes provided which should simplify testing and debugging of your app.

### Using `MockApp`
In all testing scenarios you're safe to replace `AppPlayer` with `MockApp`. Instead of establishing a connection to a
higher level frame it will mock this connection, but otherwise behave in the exact same way. It does so by using 
`MockBridge` instead of the default `PostMessageBridge`.

`MockApp` exposes a method called `fakeReceive()`, which accepts a message as the first argument and treat it the same
way it would an incoming message from the app-container.  

```typescript
import { IMessageHandlers, StartMessage, MessageTypes, MockApp } from "@screencloud/app";

// all incoming event handlers
const handlers: IMessageHandlers = {
   start: (payload) => {
      // your logic here
   },
};

// set up mock app
const app = new MockApp(handlers);

// connect the app
app.connect().then(() => {
    // and fake receive a start-message to kick of start-handler
    app.fakeReceive<StartMessage>({
        type: MessageTypes.start
    })
});
```
