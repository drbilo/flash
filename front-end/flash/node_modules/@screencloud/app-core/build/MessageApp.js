"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var Bridge_1 = require("./Bridge");
var messageValidation_1 = require("./messageValidation");
function isValidMessageTypeArray(obj) {
    return lodash_1.isArray(obj)
        && lodash_1.uniq(obj).length === obj.length
        && obj.every(function (v) { return v && lodash_1.isString(v) && (/^[a-zA-Z_]+$/g).test(v); });
}
exports.isValidMessageTypeArray = isValidMessageTypeArray;
var MessageApp = /** @class */ (function () {
    function MessageApp(handlers, bridge) {
        var _this = this;
        this.handlers = {};
        // Handlers (Incoming only)
        Object
            .keys(handlers)
            .filter(function (k) { return handlers[k]; })
            .forEach(function (k) { return handlers[k] && _this.on(k, handlers[k]); });
        // Bridge
        if (!Bridge_1.isBridge(bridge)) {
            throw new Error("invalid argument: bridge is not a valid bridge");
        }
        this.bridge = bridge;
    }
    Object.defineProperty(MessageApp.prototype, "isConnected", {
        get: function () {
            return this.bridge.isConnected;
        },
        enumerable: true,
        configurable: true
    });
    MessageApp.prototype.on = function (messageType, handler) {
        if (!lodash_1.isFunction(handler)) {
            throw new Error("handler must be callable or undefined");
        }
        if (!this.handlers[messageType]) {
            this.handlers[messageType] = [handler];
        }
        else {
            this.handlers[messageType].push(handler);
        }
        return this;
    };
    MessageApp.prototype.off = function (handler) {
        var _this = this;
        Object
            .keys(this.handlers)
            .forEach(function (k) {
            _this.handlers[k] = _this.handlers[k]
                .filter(function (x) { return x !== handler; });
        });
        return this;
    };
    MessageApp.prototype.connect = function (awaitConnection) {
        var _this = this;
        if (awaitConnection === void 0) { awaitConnection = false; }
        return this.bridge
            .connect(function (message) { return _this.receive(message); }, awaitConnection);
    };
    MessageApp.prototype.disconnect = function () {
        return this.bridge.disconnect();
    };
    MessageApp.prototype.emit = function (message) {
        if (!messageValidation_1.isMessage(message)) {
            throw new Error("invalid message");
        }
        return this.bridge.send({
            data: message,
        });
    };
    MessageApp.prototype.request = function (message, overrideOptions) {
        if (!messageValidation_1.isMessage(message)) {
            throw new Error("invalid message");
        }
        return this.bridge.request(message, overrideOptions);
    };
    MessageApp.prototype.receive = function (message) {
        // ensure we actually got a message.
        if (!messageValidation_1.isMessage(message)) {
            throw new Error("invalid message");
        }
        var type = message.type, payload = message.payload;
        // typecast to any due to typescript inference error
        // TS2349: Cannot invoke an expression whose type lacks a request signature.
        var handlers = this.handlers[type];
        try {
            if (Array.isArray(handlers)) {
                for (var k in handlers) {
                    if (lodash_1.isFunction(handlers[k])) {
                        var p = handlers[k](payload);
                        // first handler to return a promise gets to talk
                        if (p instanceof Promise) {
                            return p;
                        }
                    }
                }
            }
        }
        catch (e) {
            // todo do something with caught exceptions
            // rethrow
            throw e;
        }
    };
    return MessageApp;
}());
exports.MessageApp = MessageApp;
//# sourceMappingURL=MessageApp.js.map