import { IMessage } from "./MessageApp";
export interface IBridge {
    readonly isConnected: boolean;
    readonly isConnecting: boolean;
    connect(handler: (message: IMessage) => (undefined | Promise<any>), awaitConnection?: boolean): Promise<void>;
    disconnect(): Promise<void>;
    send<Data = any>(bridgeMessage: IBridgeMessage<Data>): void;
    request<Message extends IMessage = any, Result = any>(message: Message, overrideOptions?: Partial<IBridgeOptions>): Promise<Result>;
}
export interface IBridgeMessage<Data = any> {
    requestId?: number;
    referenceId?: number;
    isError?: undefined | boolean;
    data: Data;
}
export interface IBridgeOptions {
    timeout: number;
    connect: (awaitConnect?: boolean) => Promise<void>;
    disconnect: () => Promise<void>;
    send: (request: string) => void;
    encode?: (obj: IBridgeMessage) => string;
    decode?: (str: string) => IBridgeMessage;
}
export declare function isBridgeOptions(obj: any): obj is IBridgeOptions;
export declare function isBridgeMessage(obj: any): obj is IBridgeMessage;
export declare function isBridge(obj: any): obj is IBridge;
export declare enum BridgeState {
    AwaitingConnect = "AWAITING_CONNECT",
    Connected = "CONNECTED",
    Connecting = "CONNECTING",
    Disconnected = "DISCONNECTED",
    Disconnecting = "DISCONNECTING"
}
export declare class Bridge implements IBridge {
    protected state: BridgeState;
    readonly isConnected: boolean;
    readonly isConnecting: boolean;
    protected messageHandler: undefined | ((message: any) => undefined | Promise<any>);
    protected lastRequestId: number;
    protected promiseResolvers: {
        [referenceId: number]: {
            resolve: (result: any) => void | undefined;
            reject: (reason: any) => void | undefined;
        };
    };
    protected options: IBridgeOptions;
    constructor(options: IBridgeOptions);
    getState(): BridgeState;
    connect(handler: (message: IMessage<any, any>) => undefined | Promise<any>, awaitConnection?: boolean): Promise<void>;
    disconnect(): Promise<void>;
    emit<Data = any>(data: Data): void;
    request<Data = any, Result = any>(data: Data, overrideOptions?: Partial<IBridgeOptions>): Promise<Result>;
    send<Data = any>(bridgeMessage: IBridgeMessage<Data>): void;
    protected handleDisconnect(): void;
    protected encode(obj: IBridgeMessage): string;
    protected decode(str: string): IBridgeMessage;
    protected receive(str: string): void;
    protected handleReceivedResponse(message: IBridgeMessage): void;
    protected respondAsync(requestId: number, promise: undefined | Promise<any>): void;
}
