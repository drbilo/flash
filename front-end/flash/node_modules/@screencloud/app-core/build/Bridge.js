"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
function isBridgeOptions(obj) {
    return lodash_1.isObjectLike(obj)
        // required functions
        && ["connect", "disconnect", "send"]
            .every(function (methodName) { return lodash_1.isFunction(obj[methodName]); })
        // optional functions
        && ["encode", "decode"]
            .every(function (methodName) { return obj[methodName] === undefined || lodash_1.isFunction(obj[methodName]); })
        && lodash_1.isNumber(obj.timeout) && obj.timeout > 0;
}
exports.isBridgeOptions = isBridgeOptions;
function isBridgeMessage(obj) {
    return lodash_1.isPlainObject(obj)
        && Object.keys(obj).every(function (key) { return ["requestId", "referenceId", "data", "isError"].includes(key); })
        && lodash_1.has(obj, "data")
        && (obj.requestId === undefined || lodash_1.isNumber(obj.requestId))
        && (obj.referenceId === undefined || lodash_1.isNumber(obj.referenceId))
        && (obj.isError === undefined || obj.isError === false || obj.isError === true);
}
exports.isBridgeMessage = isBridgeMessage;
function isBridge(obj) {
    if (!lodash_1.isObjectLike(obj)) {
        return false;
    }
    var requiredProps = [
        "isConnected",
        "isConnecting",
    ];
    var requiredFuncs = [
        "connect",
        "disconnect",
        "send",
    ];
    return requiredProps.every(function (propName) { return lodash_1.hasIn(obj, propName) && !lodash_1.isFunction(obj[propName]); })
        && requiredFuncs.every(function (funcName) { return lodash_1.isFunction(obj[funcName]); });
}
exports.isBridge = isBridge;
var BridgeState;
(function (BridgeState) {
    BridgeState["AwaitingConnect"] = "AWAITING_CONNECT";
    BridgeState["Connected"] = "CONNECTED";
    BridgeState["Connecting"] = "CONNECTING";
    BridgeState["Disconnected"] = "DISCONNECTED";
    BridgeState["Disconnecting"] = "DISCONNECTING";
})(BridgeState = exports.BridgeState || (exports.BridgeState = {}));
var Bridge = /** @class */ (function () {
    function Bridge(options) {
        this.state = BridgeState.Disconnected;
        this.lastRequestId = -1;
        this.promiseResolvers = {};
        if (!isBridgeOptions(options)) {
            throw new Error("invalid argument options");
        }
        this.options = options;
    }
    Object.defineProperty(Bridge.prototype, "isConnected", {
        get: function () {
            return this.state === BridgeState.Connected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bridge.prototype, "isConnecting", {
        get: function () {
            return this.state === BridgeState.Connecting;
        },
        enumerable: true,
        configurable: true
    });
    Bridge.prototype.getState = function () {
        return this.state;
    };
    Bridge.prototype.connect = function (handler, awaitConnection) {
        var _this = this;
        if (awaitConnection === void 0) { awaitConnection = false; }
        if (!lodash_1.isFunction(handler)) {
            throw new Error("invalid argument: handler is not callable");
        }
        if (this.state !== BridgeState.Disconnected) {
            throw new Error("invalid state");
        }
        this.state = awaitConnection
            ? BridgeState.AwaitingConnect
            : BridgeState.Connecting;
        return this.options.connect(awaitConnection)
            .then(function () {
            _this.messageHandler = handler;
            _this.state = BridgeState.Connected;
        })
            .catch(function (error) {
            _this.messageHandler = undefined;
            _this.state = BridgeState.Disconnected;
            throw error;
        });
    };
    Bridge.prototype.disconnect = function () {
        var _this = this;
        if (this.state !== BridgeState.Connected) {
            throw new Error("invalid request");
        }
        this.state = BridgeState.Disconnecting;
        return this.options.disconnect().then(function () {
            _this.handleDisconnect();
        });
    };
    Bridge.prototype.emit = function (data) {
        this.send({
            data: data,
        });
    };
    Bridge.prototype.request = function (data, overrideOptions) {
        var _this = this;
        var requestId = ++this.lastRequestId;
        var options = __assign({}, this.options, overrideOptions);
        // fire and return promise
        return new Promise(function (resolve, reject) {
            _this.promiseResolvers[requestId] = {
                reject: function (reason) {
                    delete _this.promiseResolvers[requestId];
                    reject(reason);
                },
                resolve: function (result) {
                    delete _this.promiseResolvers[requestId];
                    resolve(result);
                },
            };
            if (options.timeout !== -1) {
                setTimeout(function () {
                    if (_this.promiseResolvers[requestId]) {
                        _this.promiseResolvers[requestId].reject("timeout");
                    }
                }, options.timeout);
            }
            _this.options
                .send(_this.encode({
                data: data,
                requestId: requestId,
            }));
        });
    };
    Bridge.prototype.send = function (bridgeMessage) {
        if (this.state !== BridgeState.Connected) {
            throw new Error("bridge is not connected");
        }
        this.options
            .send(this.encode(bridgeMessage));
    };
    Bridge.prototype.handleDisconnect = function () {
        var _this = this;
        // cancel all hanging requests
        Object.keys(this.promiseResolvers).forEach(function (key) {
            _this.promiseResolvers[key].reject("disconnect");
        });
        // reset handler and state
        this.messageHandler = undefined;
        this.state = BridgeState.Disconnected;
    };
    Bridge.prototype.encode = function (obj) {
        return this.options.encode
            ? this.options.encode(obj)
            : JSON.stringify(obj);
    };
    Bridge.prototype.decode = function (str) {
        return this.options.decode
            ? this.options.decode(str)
            : JSON.parse(str);
    };
    Bridge.prototype.receive = function (str) {
        var obj = this.decode(str);
        if (!isBridgeMessage(obj)) {
            throw new Error("incoming request could not be resolved into a valid bridge message");
        }
        if (!this.isConnected || !this.messageHandler) {
            throw new Error("disconnected");
        }
        if (obj.referenceId !== undefined) {
            this.handleReceivedResponse(obj);
            return;
        }
        var promiseOrUndefined = this.messageHandler(obj.data) || undefined;
        if (obj.requestId || obj.requestId === 0) {
            this.respondAsync(obj.requestId, promiseOrUndefined);
        }
    };
    Bridge.prototype.handleReceivedResponse = function (message) {
        var referenceId = message.referenceId;
        if (!referenceId && referenceId !== 0) {
            throw new Error("response is missing referenceId");
        }
        // resolve a pending promise (if it didn't timeout yet)
        var promise = this.promiseResolvers[referenceId];
        if (promise) {
            if (message.isError === true) {
                promise.reject(message.data);
            }
            else {
                promise.resolve(message.data);
            }
        }
    };
    Bridge.prototype.respondAsync = function (requestId, promise) {
        var _this = this;
        // PromiseLike
        if (!promise || !promise.then || !promise.catch) {
            this.send({
                data: "unknown error occured",
                isError: true,
                referenceId: requestId,
            });
            throw new Error("promise expected. Is your handler implemented correctly?");
        }
        promise.then(function (data) {
            _this.send({
                data: data,
                referenceId: requestId,
            });
        }).catch(function () { return null; });
        promise.catch(function (data) {
            _this.send({
                data: data,
                isError: true,
                referenceId: requestId,
            });
        });
    };
    return Bridge;
}());
exports.Bridge = Bridge;
//# sourceMappingURL=Bridge.js.map